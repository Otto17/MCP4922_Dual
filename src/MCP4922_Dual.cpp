/*
	Библиотека для удобного управления 2-х канальным ЦАП "MCP4922".
	
	Управление производится каждым каналом по отдельности.
	Изменение значений на одном канале, не влияют на выход второго канала.
	
	Дата создания: 15.01.2024г.
	Версия: 1.0
	Автор: Otto.

*/



#include "Arduino.h"
#include "MCP4922_Dual.h"



MCP4922_Dual::MCP4922_Dual(byte SDI, byte SCK, byte CS) {
 _SDI = SDI;
 _SCK = SCK;
 _CS = CS;


//Назначаем пины SPI как выходы
 pinMode(_SDI,OUTPUT);
 pinMode(_SCK,OUTPUT);
 pinMode(_CS,OUTPUT);

}

//************************************************************************
void MCP4922_Dual::SetA(int A) {
  sendValSPI_A(A);
}

void MCP4922_Dual::SetB(int B) {
  sendValSPI_B(B);
}


//************************************************************************ 
/*
Битовая маска для настройки параметров ЦАП'а MCP4922.

Четыре старших бита в маске 0b0111000000000000 (канал A) и 0b1111000000000000 (канал B)
предназначены для установка различных вариантов настройки ЦАП (страница в тех. документации №24).

0bX111000000000000 где X — канал ЦАП, в который пишет SPI.
bit15 A/B:
				   X=0 пишет на канал А.
				   X=1 пишет на канал B.

0b0X11000000000000 где X — режим с буферизацией или без буферизации.
Буферизация использует вывод LDAC для одновременного обновления обоих каналов (в этой библиотеке я не использую LDAC, поэтому этот вывод посадил на GND).
Небуферизованный режим записывает выходные данные непосредственно на выходы DAC и игнорирует вывод LDAC.
bit14 BUF:
				   X=0 не буферизовано.
				   X=1 буферизуется.

0b01x1000000000000 где X - селектор выходного усиления.  
bit13 GA:
				   X=0 это двухкратное усиление - 2x (VOUT = 2 * VREF * D/4096).
				   X=1 это однократное усиление - 1x (VOUT = VREF * D/4096).

0b011X000000000000 где X — управляющий бит отключения выходов MCP4922 (в этой библиотеке я не использую SHDN, поэтому этот вывод посадил на Vcc).
bit12 SHDN:
				   X=0 ВЫВОД MCP4922 отключён на выбранном канале.
				   X=1 ВЫВОД MCP4922 включён на выбранном канале.

0b0111XXXXXXXXXXXX где X - это 12 бит, которые должны быть записаны в активный канал. Бит с 11 до бита 0 (биты входных данных ЦАП. Бит X игнорируется).

 */
//************************************************************************


//Функции для отправки данных по SPI на канал A
void MCP4922_Dual::sendValSPI_A(int A) {
int channe_A = A | 0b0111000000000000;	// Формируем набор бит с настройками для канала "A" (настроки бит слева направо: 1-й канал(A), с буферизацией, однократное усиление, выходы включены).

digitalWrite(_CS, LOW);					// Открываем защёлку
SPI.transfer(highByte(channe_A));		// Отправляем старший бит
SPI.transfer(lowByte(channe_A));		// Отправляем младший бит
digitalWrite(_CS, HIGH);				// Закрываем защёлку

__asm__("nop\n\t");		// Ассемблерная вставка для задержки в 1 цикл (на 20МГц даёт задержку 50нс, а на 16МГц даёт задержку 62.5нс)
}


//Функции для отправки данных по SPI на канал B
void MCP4922_Dual::sendValSPI_B(int B) {
int channe_B = B | 0b1111000000000000;	// Формируем набор бит с настройками для канала "B" (настроки бит слева направо: 2-й канал(B), с буферизацией, однократное усиление, выходы включены).

digitalWrite(_CS, LOW);					// Открываем защёлку
SPI.transfer(highByte(channe_B));		// Отправляем старший бит
SPI.transfer(lowByte(channe_B));		// Отправляем младший бит
digitalWrite(_CS, HIGH);				// Закрываем защёлку

__asm__("nop\n\t");		// Ассемблерная вставка для задержки в 1 цикл (на 20МГц даёт задержку 50нс, а на 16МГц даёт задержку 62.5нс)
}
